# 实现功能

- 重写`sys_get_time`和`sys_task_info`
- 实现 `sys_mmap` 和 `sys_munmap`, 惰性页面分配

# 问答题

## 一

参考自 RiscV 手册

- **物理页框号（PPN）**: 占用页表项的部分位, 用于存储对应虚拟页映射到的物理内存页框的地址

- **Valid/Present 位（V/P）**: 表示该页表项是否有效, 即对应的页面是否已映射到物理内存中. 1 表示有效, 可以进行访问; 0 会触发缺页异常。

- **Read/Write 位（R/W）**: 页面读写权限. 1 为可读写, 0 为只读

- **Execute Disable 位（X）**: 页面是否可执行. 0 则允许执行代码

- **User/Supervisor 位（U/S）**: 是否可由用户模式下的程序访问. 1 为可访问

- **Global 位（G）**: 控制 TLB 替换策略. 1 表示该页表项对应的条目在全局 TLB 中保持有效

- **Accessed 位（A）**: 记录页面最近是否被访问过

- **Dirty 位（D）**: 记录页面内容是否被修改过, 对于写时复制和页面回写到磁盘等操作至关重要

## 二

### 可能由缺页导致的异常

- **存储访问故障（Load/Store Access Fault）**: 当处理器尝试执行加载（LW, LH, LB 等）或存储（SW, SH, SB 等）指令访问一个未映射或权限受限的页面时触发
- **指令访问故障（Instruction Access Fault）**: 如果尝试执行的指令位于一个无效或未映射的页面, 会触发此异常

### 缺页时相关重要寄存器

- **mtval**: 包含导致异常的具体故障地址
- **mepc**: 存储发生异常时的程序计数器（PC）值, 即异常指令的地址
- **mstatus**: 反映处理器状态, 包括当前特权模式（用户或内核）等信息
- **satp**: 在 SV39 模式下, 包含当前页表基址和一些页表控制位

### Lazy 策略的好处

- **减少启动时间和内存使用**: 初始时仅加载程序的基本部分或必要部分到内存, 加快程序启动速度, 并减少运行时的内存占用
- **资源高效**: 特别是对于大型程序或不常用模块, 仅在真正需要时加载, 避免了无谓的磁盘I/O和内存消耗
- **提升系统响应性**: 系统可以在需要时动态分配资源, 而不是一开始就分配大量可能不会使用的内存

### SV39 页表大小估算

SV39 使用 9 位的虚拟页偏移, 因此每级页表项指向的是一级更小粒度的页表或最终的物理页. 整个虚拟地址空间为 2^39 字节. 对于三级页表结构, 每级索引需要 9 位, 加上有效位, 权限位等, 假设每项至少 10 位, 整个页表大小约为: 2^12 + 2^19 + 2^28 字节, 考虑到实际使用中的稀疏性, 实际占用会远小于这个理论最大值

### 实现 Lazy 策略的方法

- **保留页表项标记**: 在页表项中设置特殊的标记（如未初始化或待加载标志）, 当发生访问时, OS 检测到此标记, 执行页面加载操作, 并更新页表项为有效
- **缺页处理例程**: 在缺页异常处理程序中, 检查异常原因, 如果是 Lazy 加载引起的, 根据页表项中记录的磁盘地址信息, 加载数据到物理内存, 更新页表项, 并重新执行引起异常的指令

### Swap 策略在页表项的表现

在 swap 策略下, 当页面被换出到磁盘时, 相应的页表项通常会被标记为无效（V/P 位设为0）, 同时可能还会设置其他标志位来指示该页面已被换出（具体位的使用依据操作系统实现可能有所不同，有的系统可能会使用预留的位来专门标记这一状态）. 当 CPU 尝试访问这些页面时, 会因为页表项无效而产生缺页异常, 从而触发操作系统从磁盘重新载入页面到内存并更新页表项的过程

## 三

### 单页表情况下更换页表

在传统的单页表模型中, 用户线程和内核线程共享同一张页表, 通常通过页表中的权限位来控制对内核地址的访问, 操作系统会改变 CPU 的权限级别, 这会导致处理器对页表中权限位的解释发生变化, 从而间接实现 "访问权限" 的切换

### 单页表控制用户态访问内核页面

在单页表设计中, 控制用户态程序无法直接访问内核页面是通过页表项中的权限位实现的, 尤其是 U/S 位. 当一个页面被标记为仅内核可访问时, 处理器在用户态执行时尝试访问该页面就会触发一个保护异常, 从而阻止非法访问

### 单页表的优势

- **内存效率高**: 单页表模型减少了页表的总量, 因为所有线程共享一套页表, 降低了内存使用量
- **上下文切换快**: 不需要在用户态和内核态之间切换时更换页表, 减少了上下文切换的开销
- **实现简单**: 相较于多页表模型, 单页表的设计和维护更为直接, 减少了操作系统复杂度

### 双页表实现下更换页表时机

在双页表模型, 通常存在用户空间页表和内核空间页表, 目的是隔离用户空间和内核空间以提高安全性. 在这种情况下, 更换页表通常发生在用户态到内核态的转换和反向转换时

如果设计一个单页表操作系统, 并考虑安全增强, 虽然传统单页表模型不涉及频繁的页表切换，但特定场景下可以模拟类似行为, 比如在执行敏感操作前临时限制用户态对某些内核区域的访问. 但不如直接采用双页表设计来得直接有效, 因此应尽可能维持单页表模型的传统优势

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   - 无

2. 此外，我也参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   - RiscV 手册
   - New Bing 做出的一些解释

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。