# 实现功能

- 通过新增 `TaskInfo` 结构查询当前正在执行的任务信息, 包括以下几部分
  - 任务状态
  - 任务调度所需时间
  - 系统调用使用次数

# 简答作业

## 一

- SBI 版本: 仓库自带
- `ch2b_bad_address`: 试图向无效地址 `0x0` 写入`0`, 触发 `Store` 相关的异常, 跳转到 `__alltraps`, call `trap_handler` 函数进行处理, 最后执行 `exit_current_and_run_next` 来执行下一个任务
- `ch2b_bad_instructions`: 试图执行 S 模式指令 `sret`, 触发 `Exception::IllegalInstruction`, 剩余流程同上
- `ch2b_bad_register`: 试图读取 S 模式寄存器 `sstatus`, 触发 `Exception::IllegalInstruction`, 剩余流程同上

## 二

### 1

`a0` 有三种可能

- 从 `run_first_task` 出发, 因为是第一个任务, 此时 `a0` 为 `TaskContext::zero_init()` 的地址
- 从 `run_next_task` 出发, 因此 `a0` 为 `TaskManager` 的上一个 `TaskContext` 的地址
- 从 `__alltraps` 出发, 在 `call trap_handler` 返回后执行至 `__restore`, `a0` 为 `trap_handler` 返回的地址

两种使用情景:

- 从 S 切换至 U 模式时
- 从 U 切换至 S 模式时保存状态, 执行 `trap_handler` 之后恢复状态

### 2

- `ld t0, 32*8(sp)`: 从栈中加载数据到临时寄存器 `t0`. 栈指针 `sp` 向下偏移 32 个字, 用以恢复保存在栈上的 SSTATUS 寄存器的值

- `ld t1, 33*8(sp)`: 从栈中加载数据到 `t1` 寄存器, 偏移量为 33 个字, 用以恢复 SEPC 计数器. 在用户态到内核态的切换中, SEPC 用于记录用户态程序中断前的下一条指令地址, 以便在返回用户态时继续执行

- `ld t2, 2*8(sp)`: 从栈中加载数据到 `t2` 寄存器, 偏移量为 2 个字. 存放的是SSCRATCH, 用以在特权级切换时保存和恢复一个寄存器的值, 用于异常处理中用于存储临时数据, 避免覆盖重要寄存器

- `csrw sstatus, t0`: 写入 SSTATUS 寄存器, 使用之前从栈中恢复的值. 可以控制 CPU 的特权模式, 如设置 SPP 位以进入用户态. 在从内核态返回用户态时，需要确保 SSTATUS 中的用户模式位被正确设置为 0

- `csrw sepc, t1`: 写入 SEPC 寄存器, 设定当处理器返回用户态时执行的第一条指令地址, 这是异常处理或系统调用完成后, 继续执行用户程序的关键步骤

- `csrw sscratch, t2`: 写入 SSCRATCH 寄存器, 恢复之前保存的寄存器值. 通常发生在准备从内核态返回用户态之前, 确保内核在处理异常或系统调用期间使用的临时存储不会丢失, 并且不会干扰用户态的执行环境

### 3

总的来说, `x2` 和 `x4` 寄存器的值已在上下文中被正确设置, 无需我们手动设置

### 4

- `sp`: 变成了原先 sscratch 寄存器中的值, 即现在 sp 指向了用户态的栈顶, 处理器准备好在用户态的栈上执行后续指令

- `sscratch`: 变成了执行此指令前 sp 的值, 即之前内核栈的栈顶地址, 以便在下次从用户态返回内核态时, 可以再次恢复内核栈的使用

### 5

参考自 RiscV 手册, 状态切换发生在最后一条指令: `sret` (System mode Return). 用于从异常或中断处理返回, 并且可以用于从内核态返回到用户态.

当执行 `sret` 时处理器会执行以下关键操作:

-  **恢复用户态的程序计数器**: `sret`会从 SEPC 中读取并设置 PC 到用户态程序的下一条指令地址

-  **恢复用户态状态**: 执行 `sret` 之前, 通过 `csrw sstatus, t0` 指令恢复了 SSTATUS 寄存器的内容, 其中包括了用户态标志位用以确保了处理器在执行 `sret` 后进入用户态模式

-  **栈指针的最终调整**：在 `sret` 之前, 栈指针 `sp` 通过 `csrrw sp, sscratch, sp` 恢复为用户态栈的顶部地址, 确保了在用户态执行时, 栈操作针对的是正确的栈空间

### 6

类似第 4 条, 交换了 `sscratch` 和 `sp` 的值

- `sscratch`: 用户栈栈顶
- `sp`: 内核栈栈顶

### 7

从用户态进入内核态并不直接体现在单条指令上, 而是通过一系列包括中断, 异常或系统调用触发的. 比如这段代码中就没有比较直接的 ecall 指令, 但可以认为这些是中断处理或系统调用处理的一部分.

不过一旦进入内核态, `__alltraps` 第一条执行的指令虽然不是直接引起状态转换的指令, 但在异常处理流程中非常关键, 标志着开始在内核栈上保存状态, 为处理异常或系统调用做准备. 而在这之前, CPU 已经自动完成了从用户态到内核态的转换, 并设置了相应的状态, 如修改 SSTATUS 寄存器的模式位等


# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   - 无

2. 此外，我也参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   - RiscV 手册
   - New Bing 做出的一些解释

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。